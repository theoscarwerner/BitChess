import numpy as np
from pieces.piece import Piece
from precomputations.king import precomputed_moves
from utils import pp_bits

king_castle_map = [
    [ # Black
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0000
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0001
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0010
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0011
        np.uint64(0b0000001000000000000000000000000000000000000000000000000000000000),  # 0100
        np.uint64(0b0000001000000000000000000000000000000000000000000000000000000000),  # 0101
        np.uint64(0b0000001000000000000000000000000000000000000000000000000000000000),  # 0110
        np.uint64(0b0000001000000000000000000000000000000000000000000000000000000000),  # 0111
        np.uint64(0b0010000000000000000000000000000000000000000000000000000000000000),  # 1000
        np.uint64(0b0010000000000000000000000000000000000000000000000000000000000000),  # 1001
        np.uint64(0b0010000000000000000000000000000000000000000000000000000000000000),  # 1010
        np.uint64(0b0010000000000000000000000000000000000000000000000000000000000000),  # 1011
        np.uint64(0b0010001000000000000000000000000000000000000000000000000000000000),  # 1100
        np.uint64(0b0010001000000000000000000000000000000000000000000000000000000000),  # 1101
        np.uint64(0b0010001000000000000000000000000000000000000000000000000000000000),  # 1110
        np.uint64(0b0010001000000000000000000000000000000000000000000000000000000000),  # 1111
    ],
    [ # White
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0000
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000010),  # 0001
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100000),  # 0010
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100010),  # 0011
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 0100
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000010),  # 0101
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100000),  # 0110
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100010),  # 0111
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 1000
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000010),  # 1001
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100000),  # 1010
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100010),  # 1011
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000),  # 1100
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000000010),  # 1101
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100000),  # 1110
        np.uint64(0b0000000000000000000000000000000000000000000000000000000000100010),  # 1111
    ],
]


class King(Piece):
    def __init__(self, color):
        self.idx = 7
        self.color = color

    def get_valid_moves(self, square, gamestate):
        # TODO: Castling: Check if king passes through check

        # This method is pretty damn ugly. Is pretty inefficient as castle checks are made even if
        # The king / rook has moved
        empty_castle_directions = np.uint64(0b0000000000000000000000000000000000000000000000000000000000000000) # NOQA
        pieces = gamestate.board[-1]
        if self.color == 0:
            if pieces & np.uint64(0b0111000000000000000000000000000000000000000000000000000000000000) == 0:  # NOQA
                empty_castle_directions |= np.uint64(0b0010000000000000000000000000000000000000000000000000000000000000) # NOQA
            if pieces & np.uint64(0b0000011000000000000000000000000000000000000000000000000000000000) == 0:  # NOQA
                empty_castle_directions |= np.uint64(0b0000001000000000000000000000000000000000000000000000000000000000) # NOQA
        else:
            if pieces & np.uint64(0b0000000000000000000000000000000000000000000000000000000001110000) == 0:  # NOQA
                empty_castle_directions |= np.uint64(0b0000000000000000000000000000000000000000000000000000000000100000) # NOQA
            if pieces & np.uint64(0b0000000000000000000000000000000000000000000000000000000000000110) == 0:  # NOQA
                empty_castle_directions |= np.uint64(0b0000000000000000000000000000000000000000000000000000000000000010) # NOQA

        # Without castling
        moves = precomputed_moves[square.square_index] & (~gamestate.board[self.color])
        # "Append" castle moves
        moves = moves | (king_castle_map[self.color][gamestate.castle_rights] & empty_castle_directions)  # NOQA
        return moves

